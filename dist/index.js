import b from "path";
import g from "dotenv";
import m from "fs";
import $ from "prettier";
const h = (e) => e.global ? typeof e.global == "string" ? e.global : e.global() : "process", d = (e) => e.name ? typeof e.name == "string" ? e.name : e.name() : "env", N = (e) => {
  if (e.generatedTypesPath)
    return typeof e.generatedTypesPath == "string" ? e.generatedTypesPath : e.generatedTypesPath();
}, T = (e) => typeof e == "number" && !Number.isNaN(e) ? !0 : typeof e != "string" ? !1 : !Number.isNaN(Number(e)) && !Number.isNaN(Number.parseFloat(e)), E = (e) => typeof e == "boolean" ? !0 : typeof e != "string" ? !1 : !!["true", "1", "yes", "on", "false", "0", "no", "off"].includes(e.trim().toLowerCase()), y = (e) => T(e) ? "number" : E(e) ? "boolean" : typeof e, j = (e, i) => ["MODE", "BASE_URL", "PROD", "DEV", "SSR"].includes(e) ? !0 : i.some((t) => e.startsWith(t)), F = (e = { injectHtml: !0 }) => {
  let i = {}, s, t, l;
  return {
    name: "vite-plugin-runtime-env",
    configResolved(r) {
      s = r;
      let n = s.envPrefix ?? ["VITE_"];
      typeof n == "string" && (n = [n]), l = n, t = { ...e, ...s.runtimeEnv };
    },
    buildStart() {
      const r = b.resolve(s.root, s.envDir, ".env");
      m.existsSync(r) && (i = { ...i, ...g.parse(m.readFileSync(r)) });
      const n = b.resolve(s.root, s.envDir, `.env.${s.mode}`);
      if (m.existsSync(n) && (i = { ...i, ...g.parse(m.readFileSync(n)) }), Object.keys(i).forEach((u) => {
        j(u, l) && delete i[u];
      }), t.generateTypes && s.command === "serve") {
        const u = N(t) ?? s.root, o = d(t), f = b.resolve(u, `${o}.d.ts`), v = o === "env" ? "ImportMetaEnv" : "ImportMetaRuntimeEnv";
        let c = `/// <reference types="vite/client" />

/** generated by vite-plugin-runtime */
interface ${v} {`;
        Object.entries(i).forEach((p) => {
          c += `readonly ${p[0]}: ${y(p[1])};`;
        }), c += `} interface ImportMeta {readonly ${o}: ${v};}`, $.format(c, {
          semi: !0,
          singleQuote: !0,
          arrowParens: "avoid",
          tabWidth: 2,
          useTabs: !1,
          printWidth: 100,
          parser: "typescript"
        }).then((p) => m.writeFileSync(f, p));
      }
    },
    transformIndexHtml() {
      if (t.injectHtml !== !0)
        return;
      const r = h(t), n = d(t);
      let a;
      return s.command === "serve" ? a = `if(globalThis.${r} === undefined) globalThis.${r} = {}; ${r}.${n} = {...${r}.${n}, ...${JSON.stringify(i)}};` : a = `if(globalThis.${r} === undefined) globalThis.${r} = {}; import rtenv from '/${n}.js'; ${r}.${n} = {...${r}.${n}, ...rtenv};`, [
        {
          tag: "script",
          attrs: {
            type: "module"
          },
          children: a,
          injectTo: "head-prepend"
        }
      ];
    },
    generateBundle() {
      const r = d(t), n = {}, a = {};
      Object.entries(i).forEach((o) => {
        const f = y(o[1]);
        n[o[0]] = f === "number" ? Number(o[1]) : f === "boolean" ? !!o[1] : o[1], t.envsubstTemplate === !0 && (a[o[0]] = `$${o[0]}`);
      });
      const u = `export default ${JSON.stringify(n)} ;`;
      if (t.generateFile === !0 && this.emitFile({
        type: "asset",
        fileName: `${r}.js`,
        source: u
      }), t.envsubstTemplate === !0) {
        const o = `export default ${JSON.stringify(a)} ;`;
        this.emitFile({
          type: "asset",
          fileName: `${r}.template.js`,
          source: o
        });
      }
    }
  };
}, H = (e) => {
  let i, s;
  return {
    name: "vite-plugin-runtime-html",
    configResolved(t) {
      i = t, s = { ...e, ...i.runtimeHtml };
    },
    transformIndexHtml() {
      return (s[i.mode] ?? []).map((l) => typeof l == "function" ? l() : l);
    }
  };
};
export {
  F as runtimeEnv,
  H as runtimeHtml
};
